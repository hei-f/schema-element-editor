---
alwaysApply: false
---

# Chrome插件发布流程

这是一个chrome插件项目，其代码托管在github上。

当用户说'执行发布流程'或者类似的命令时，你需要执行项目的发布流程。

## 发布流程步骤

### 1. 前置检查
- 检查git工作区状态（`git status`）
- 确认是否有未提交的改动，如有则在步骤2中进行原子化提交

### 2. 分析并原子化提交功能改动

**2.1 分析工作区改动**
- 使用 `git status` 查看所有未提交的文件
- 使用 `git diff` 逐文件分析具体改动内容：
  - 识别每个文件中的改动块（hunks）和具体行号
  - 分析每个改动块的功能意图
  - 注意同一文件中可能包含多个不相关的改动
- 识别改动类型（新功能、bug修复、代码重构、性能优化、文档更新等）
- **关键**：必须精确到文件内的具体改动行，而不是整个文件

**2.2 原子化分组**
将所有改动按照**原子化提交原则**进行分组：
- **原子化标准**：每组改动应聚焦于单一具体功能或改动点
  - 一个功能点的所有相关文件和行归为一组
  - 一个bug修复的所有相关文件和行归为一组
  - 一类相关的代码优化归为一组
  - **关键**：同一文件内的不同功能改动必须拆分到不同的提交组
  - 例如：文件A中的第10-15行是功能X，第50-60行是功能Y，应拆分为两个提交组
  - 避免在一个提交中混合不相关的改动
- **重要**：暂时忽略版本号相关文件（package.json, src/manifest.json, src/options/OptionsApp.tsx中的版本号），这些将在步骤9中单独提交
- **输出格式**：对每个提交组，明确列出：
  - 提交组编号
  - 功能描述
  - 涉及的文件及具体行号范围（格式：`文件路径:行号范围`，如 `src/App.tsx:10-15,50-60`）

**2.3 逐组提交功能改动**
按分组顺序，依次提交每组改动：

对于每组改动：

1. **展示改动详情**：
   - 明确列出本组涉及的所有文件及行号范围
   - 使用 `git diff` 展示具体的代码改动内容
   - 确认改动内容与预期的提交功能一致

2. **生成commit message**，遵循以下规范：
   - **质量要求**：必须清晰概括改动内容，让人一眼看懂做了什么
   - **格式**：`{类型前缀}: {具体改动描述}`
   - **类型前缀**：
     - `feat:` 新增功能
     - `fix:` 修复问题
     - `refactor:` 代码重构（不改变功能）
     - `perf:` 性能优化
     - `docs:` 文档更新
     - `style:` 代码格式调整（不影响逻辑）
     - `test:` 测试相关
     - `chore:` 其他杂项（如构建配置、依赖更新等）
   - **描述要求**：
     - 使用有意义的动词描述具体行为（如：添加、修复、优化、重构）
     - 包含改动的核心要点，避免模糊描述
     - 示例：`fix: 修复用户登录验证逻辑` 而非 `update code`

3. **执行部分暂存提交**：
   
   **情况A：该组包含完整文件的所有改动**
   - 直接使用：`git add {文件路径1} {文件路径2} ...`
   - 然后执行：`git commit -m "{message}"`
   
   **情况B：该组仅包含文件的部分改动（行级别提交）**
   
   通过构造临时patch文件实现精确的行级别暂存（AI自动化操作）：
   
   a. **生成完整diff**：
      - 执行：`git diff -- {文件路径} > .git/temp_commit.patch`
      - 获取该文件的所有改动内容
   
   b. **读取并分析diff内容**：
      - 读取 `.git/temp_commit.patch` 文件
      - 解析diff格式，识别所有的hunks（改动块）
      - 每个hunk的格式为：`@@ -旧文件起始行,行数 +新文件起始行,行数 @@`
   
   c. **构造部分patch**：
      - 根据本组需要提交的行号范围，提取对应的hunks
      - 创建新的patch文件 `.git/partial_commit.patch`，只包含：
        - diff文件头信息（`diff --git`, `index`, `---`, `+++` 等）
        - 需要提交的hunks（保持完整的hunk格式）
      - **重要**：必须保持patch文件的格式完整性和上下文行
   
   d. **应用部分改动到暂存区**：
      - 执行：`git apply --cached --unidiff-zero .git/partial_commit.patch`
      - 如果失败，尝试：`git apply --cached .git/partial_commit.patch`（允许上下文行）
   
   e. **提交并清理**：
      - 执行：`git commit -m "{message}"`
      - 清理临时文件：`rm .git/temp_commit.patch .git/partial_commit.patch`
   
   f. **验证**：
      - 使用 `git show HEAD` 确认提交内容正确
      - 使用 `git diff` 确认未提交的改动仍在工作区
   
   **情况C：同时处理多个文件的部分改动**
   
   合并多个文件的部分改动到一个patch（AI自动化操作）：
   
   a. **逐个文件生成diff并提取目标hunks**：
      - 对每个文件执行情况B的步骤a-c
      - 将每个文件的部分patch内容追加到同一个 `.git/combined_commit.patch` 文件
   
   b. **应用合并的patch**：
      - 执行：`git apply --cached --unidiff-zero .git/combined_commit.patch`
      - 如果失败，尝试调整参数或拆分应用
   
   c. **提交并清理**：
      - 执行：`git commit -m "{message}"`
      - 清理所有临时patch文件

4. **验证提交结果**：
   - 使用 `git show HEAD` 查看刚才的提交内容
   - 确认提交的改动与预期完全一致
   - 使用 `git status` 确认工作区状态，未暂存的改动应该还保留在工作区

**2.4 工作区检查**
提交完功能改动后，检查工作区状态：
- 如果工作区已干净（除了可能的版本号文件），继续下一步
- 如果仍有未提交的功能文件，提示用户确认是否继续

### 3. 测试验证与质量检查

**3.1 TypeScript 类型检查**
- 执行类型检查命令：`tsc --project tsconfig.build.json`
  - 使用 `tsconfig.build.json` 配置（专为构建设计，已内置 incremental 配置，排除测试文件）
- **强制要求**：所有源代码 TypeScript 文件必须无类型错误
- 如果发现类型错误：
  - **立即终止发布流程**
  - 清晰列出所有类型错误的文件路径、行号及错误信息
  - 分析错误原因并修复所有类型错误
  - 修复完成后，将修复代码按原子化原则提交
  - 重新执行类型检查直到通过
- **输出格式**：
```
TypeScript 类型检查结果：
- 错误数：0 ✓
状态：✓ 类型检查通过，可以继续
```

**3.2 运行完整测试套件并验证通过率**
- 执行完整测试命令：`npm test` 或 `jest`
- **强制要求**：所有测试必须100%通过，不允许有任何失败或错误的测试用例
- 如果发现测试失败：
  - **立即终止发布流程**
  - 清晰列出失败的测试用例名称及错误信息
  - 分析失败原因（代码问题、测试用例问题、环境问题等）
  - 修复所有失败的测试
  - 修复完成后，必须重新从步骤1开始执行发布流程
- **输出格式**：
```
测试执行结果：
- 总测试数：X
- 通过：X
- 失败：0 ✓
- 跳过：X（如有）
状态：✓ 所有测试通过，可以继续
```

**3.3 运行测试覆盖率分析**
- 执行测试覆盖率命令：`npm run test:coverage` 或 `jest --coverage`
- 等待测试运行完成，获取覆盖率报告

**3.4 分析本次改动的测试覆盖情况**
- 识别步骤2中已提交的所有功能改动文件
- 在覆盖率报告中查找这些文件的覆盖率数据
- 重点关注以下指标：
  - 语句覆盖率（Statement Coverage）
  - 分支覆盖率（Branch Coverage）
  - 函数覆盖率（Function Coverage）
  - 行覆盖率（Line Coverage）

**3.5 识别测试缺失的代码**
对于每个改动文件，检查：
- 覆盖率是否达标（建议：关键业务逻辑≥80%，普通代码≥70%）
- 新增的函数/方法是否有测试用例
- 修复的bug是否有回归测试
- 边界情况和异常处理是否有测试覆盖

**输出格式**：
```
文件：src/components/Example.tsx
- 当前覆盖率：45%（不达标）
- 缺失测试的函数：
  - handleSubmit (第25-40行)
  - validateInput (第50-65行)
- 未覆盖的分支：
  - 错误处理分支（第30行）
```

**3.6 补充测试用例**
如果存在测试覆盖不足的情况：

1. **向用户说明情况**：
   - 明确列出哪些文件/函数缺少测试
   - 解释为什么需要测试（如关键业务逻辑、容易出错的地方等）

2. **协助编写测试用例**：
   - 分析待测试代码的功能和逻辑
   - 设计测试场景（正常流程、边界情况、异常情况）
   - 编写测试代码，遵循项目的测试规范
   - 确保测试用例清晰、可维护

3. **提交测试代码**：
   - 将测试文件添加到暂存区
   - 使用commit message格式：`test: 添加{模块名}的测试用例`
   - 执行提交：`git add {测试文件路径}`
   - 执行：`git commit -m "test: 添加{具体功能}的测试用例"`

4. **验证测试覆盖率**：
   - 重新运行测试覆盖率命令
   - 确认覆盖率是否达标
   - 如果仍有不足，重复步骤2-4

**3.7 特殊情况处理**
- **纯UI组件或样式调整**：可以适当放宽覆盖率要求，但关键交互逻辑仍需测试
- **文档或配置文件改动**：无需测试，直接跳过本步骤
- **测试框架或测试工具本身的改动**：需要特别谨慎，确保不影响现有测试的正确性
- **紧急修复**：如果是紧急线上问题修复，可以先发布，但必须在后续版本补充测试

**3.8 完成检查**
确认以下三个条件都已满足后，继续下一步骤：
- ✓ TypeScript 类型检查通过（步骤3.1）
- ✓ 所有测试用例100%通过（步骤3.2）
- ✓ 所有改动文件的测试覆盖率达标（步骤3.3-3.7）

### 4. 版本更新确认与分析

**4.1 分析上次版本tag以来的commit历史**
- 获取当前版本号：从 `package.json` 中读取当前版本
- 查找上一个版本tag：执行 `git tag -l "v*" --sort=-v:refname | head -1`
- 分析commit历史：执行 `git log <上次版本tag>..HEAD --oneline`（如果是首次发布或找不到tag，则使用 `git log --oneline`）
- 提取所有commit message的类型前缀

**4.2 根据commit内容推荐版本更新级别**
根据**语义化版本规范（Semantic Versioning）**分析commit内容：

**版本更新判断规则**：
- **major（主版本）**：如果存在以下情况，建议更新主版本号
  - commit message包含 `BREAKING CHANGE` 或 `!`（如 `feat!:`, `fix!:`）
  - 重大架构调整或API变更
  - 不兼容的功能修改

- **minor（次版本）**：如果存在以下情况且无major级别变更，建议更新次版本号
  - commit message包含 `feat:` 前缀（新增功能）
  - 新增用户可见的功能特性
  - 向后兼容的功能增强

- **patch（修订版本）**：如果仅存在以下情况，建议更新修订版本号
  - commit message包含 `fix:` 前缀（问题修复）
  - commit message包含 `perf:` 前缀（性能优化）
  - 向后兼容的bug修复

- **无需更新版本**：如果commit仅包含以下类型
  - `docs:` 纯文档更新
  - `style:` 代码格式调整（不影响功能）
  - `test:` 测试相关
  - `chore:` 构建配置、依赖更新等（不包括release提交）

**4.3 向用户展示分析结果并确认**
- 列出自上次版本以来的所有commit（用列表形式展示）
- 标注每个commit的类型和重要程度
- **明确给出版本更新建议**：
  - 格式：`根据commit分析，建议更新版本号级别：[major/minor/patch/无需更新]`
  - 说明理由：列举关键的commit类型和数量
  - 示例：`建议：minor（次版本） - 检测到2个feat类型commit，新增了X和Y功能`
- 询问用户确认：
  - **接受建议**：按推荐的版本级别更新
  - **自定义**：用户指定版本级别（major/minor/patch）
  - **不更新版本**：跳过版本相关步骤，直接进入构建流程

**4.4 特殊情况处理**
- 如果无法确定版本更新级别（如commit message不规范），明确提示用户并提供commit列表供手动判断
- 如果检测到混合类型的commit（如既有feat又有BREAKING CHANGE），按最高级别推荐
- 如果没有新的commit（仅步骤2提交的内容），基于步骤2的提交进行分析

### 5. 更新版本号（如需要）
同时更新以下文件中的版本号：
- `package.json` 中的 `version` 字段
- `src/manifest.json` 中的 `version` 字段
- `src/features/options-page/OptionsApp.tsx` 中的版本号显示（搜索 `<VersionTag>v` 并更新版本号）
- `README.md` 中的版本号badge（搜索 `badge/version-` 并更新版本号）
- 版本号格式：`major.minor.patch`（如 `1.2.3`）

### 6. 检查README文档更新
根据本次提交的改动内容，判断是否需要更新README文档：
- **需要更新的情况**：
  - 新增功能或移除功能
  - 修改了用户使用方式或配置方法
  - 更改了安装步骤或依赖要求
  - 修复了影响用户体验的重要问题
  - 更新了API或接口
- **检查要点**：
  - 功能介绍是否需要补充或修改
  - 使用说明是否需要更新
  - 截图或示例是否需要更换
- **操作**：
  - 向用户确认是否需要更新README
  - 如需要，帮助用户修改README
  - 等待用户完成对README修改的确认后继续后续流程
  - 注：README更新会在步骤9中作为独立的 `docs:` 类型提交

### 7. 构建打包并生成压缩包
执行打包命令：`tnpm run package`
- 该命令会自动清理旧的dist目录、重新构建并生成zip包
- 打包失败则终止流程，提示用户检查错误

### 8. 验证产物
检查生成的zip包是否存在且大小合理

### 9. 提交版本号和文档改动

**9.1 提交版本号更新（如有版本更新）**
- `git add package.json src/manifest.json src/options/OptionsApp.tsx`
- `git commit -m "chore: release v{版本号}"`

**9.2 提交README更新（如有README改动）**
- `git add README.md`
- `git commit -m "docs: 更新README文档"`

### 10. 推送到远程
所有提交完成后，执行：`git push`

### 11. 创建并推送Tag（仅版本更新时）
- Tag命名格式：`v{版本号}`（如 `v1.2.3`）
- 创建tag：`git tag v{版本号}`
- 推送tag：`git push origin v{版本号}`

### 12. 生成Release内容（仅版本更新时）
生成适用于GitHub Release的内容：
- **Title格式**：`v{版本号}`
- **Description要求**：
  - 使用代码块包裹的Markdown格式
  - 简洁明了，只概括核心改动点
  - 使用列表形式，每项一行
  - 分类展示（如：新增功能、问题修复、性能优化等）
  - 避免冗余描述和技术细节

### 13. 发布总结
向用户展示：
- 本次发布的版本号（如有）
- 改动摘要
- 生成的产物路径
- 下一步操作建议（如：手动上传zip到Chrome Web Store）

## 错误处理
任何步骤失败时：
1. 立即停止后续流程
2. 清晰告知失败的步骤和原因
3. 提供可能的解决建议
4. 等待用户处理后再继续
